118D
DPを使ってちょうどnの本数使うパスを求めておく。
この時dpには桁数を記録していきその本数を使用する際桁数の一番大きいものだけ記録していく。
そうすることによりi本使うときに一番大きい桁数でしかもその前に使っていた本数も逆にたどることで求められる。
この時dpには桁数を記録していきその本数を使用する際桁数の一番大きいものだけ記録していく。
このdpで正解となる最大の数字を取り出すためにパスの調べ方を大きい順にしらべテイクという工夫がいる。
難しい。

119D
扱いやすいようにデータを拡張、
欲しい周辺の情報とその組み合わせだけを考慮することで時間を短縮する
upper boundから得られるイテレーターはその値より大きい。
125 D　メモ
実験すると操作によってーを右に寄せることが出来る。
またその数は１または０。
この一つは操作によって好きな位置に動かせる。

125 C メモ
Ｄより難しい。
一つの数字を好きに書き換えられる時のgcdは、
それを抜きにしたgcdを求めることに等しい。
さらにあらかじめ両端からgcdを求めて持っておけば、全探索できる。

123 D メモ
３重にして枝狩りしても、２重を２回でも間に合う。
c++は10^8ループまで間に合うらしい。
priority queue を使うってbfsっぽくしても溶ける。
